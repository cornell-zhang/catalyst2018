Communication Tutorial
---

### Introduction
In this tutorial, you will learn how you can use WiFi to communicate with your Seeeduino Cloud. The reason we will be using the Seeeduino Cloud as opposed to the Arduino Uno, is that the only way you can use WiFi with an Uno is if you use an external WiFi chip(like we are doing in the first tutorial). The WiFi chip we are using, the CC3000, however, is very sensitive, and so it won't work when you turn the motors of your robot on. For this reason, if you have chosen to do project 2, we have chosen to use the Seeeduino Cloud, which contains its very own WiFi module, that isn't as sensitive as the CC3000. You should note that the Seeeduino Cloud is compatible with the Arduino Yun, which is a discontinued series of the Arduino line. Since it's discontinued, however, we had no way to get a hold of them, so we will be using the Seeeduino Cloud instead, for this project.

To start, you will first need the necessary materials, which include a robot and a Seeeduino. When you get your Seeeduino, you will want to note down the label that's on the bottom of it, as it will be necessary later on. When you get your robot, you will find that the Arduino Uno is still at the bottom of the circuit stack, on top of the robot. So that we can use the WiFi module from the Seeeduino, while keeping the other robot functionality the same as in lab 2, you will have to unplug the Arduino Uno from the bottom of the circuit stack, and replace it with the Seeeduino Cloud. Make sure that when you plug in the Seeeduino Cloud, you aren't bending any pins away from their respective sockets. If you end up making this mistake, you may find that some parts of your robot aren't working, as not all the signals from the Seeeduino Cloud will be sent to the rest of the circuit stack. 

### Communicating with the Seeeduino Cloud
After having done this, you can get started with attempting to communicate with your Seeeduino Cloud, using the *communication.ino* file that's located in this directory. Be sure not to use the file from the other Communication Tutorial, as that includes code that is specific to the CC3000 WiFi chip. After having opened this file, you will likely first notice that there are some extra libraries that we will be using. Note that these are Arduino Yun libraries, and since the Seeeduino Cloud is compatible with the Arduino Yun, they will work just fine with the Seeeduino Cloud as well. We have also defined a port, and two other variables-- one is a chat server, while the other is the client(which we can use to see whether there has been anything sent via the chat server). When you are starting up the chat server to your Seeeduino Cloud, you will have to change the port number depending on the table below. Each of the Seeeduino Clouds will have a specific number on them, and depending on that number, they will listen to a different port. This means that you will have to change the port number depending on your Seeeduino Cloud's number, so that you can build a working chat server for your Seeeduino Cloud. You will also have to log into the appropriate group when you are using the Digitrec system, so that you can send the digits to the appropriate port. You may refer to the table below, to figure out which port and group number you should be using. It isn't necessary that you understand all the code, but you can look through the code and ask TA's if you have any questions about what something does. 

|Seeeduino Cloud Label | Port # | Group # |
|----------------------|--------|---------|
|A                     |        |         |
|B                     |        |         |
|C                     |        |         |

We will end here with an extremely brief overview of what is going on in both the setup section and in the main loop of the code. In the setup section of the code, we are starting up the chat server between the Seeeduino Cloud and the specific port that we want the Seeeduino Cloud to listen to. After this setup code, we keep polling (checking continuously) in the main loop to see whether something else has appeared at the port we are listening to. If something has, we are reading that value, and printing the result to the serial monitor.
